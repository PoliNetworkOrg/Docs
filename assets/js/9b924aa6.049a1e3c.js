"use strict";(self.webpackChunkpolinetworkdocs=self.webpackChunkpolinetworkdocs||[]).push([[707],{3905:(e,n,i)=>{i.d(n,{Zo:()=>c,kt:()=>f});var o=i(7294);function t(e,n,i){return n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i,e}function a(e,n){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),i.push.apply(i,o)}return i}function r(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?a(Object(i),!0).forEach((function(n){t(e,n,i[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(i,n))}))}return e}function l(e,n){if(null==e)return{};var i,o,t=function(e,n){if(null==e)return{};var i,o,t={},a=Object.keys(e);for(o=0;o<a.length;o++)i=a[o],n.indexOf(i)>=0||(t[i]=e[i]);return t}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)i=a[o],n.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(t[i]=e[i])}return t}var s=o.createContext({}),p=function(e){var n=o.useContext(s),i=n;return e&&(i="function"==typeof e?e(n):r(r({},n),e)),i},c=function(e){var n=p(e.components);return o.createElement(s.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var i=e.components,t=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(i),m=t,f=u["".concat(s,".").concat(m)]||u[m]||d[m]||a;return i?o.createElement(f,r(r({ref:n},c),{},{components:i})):o.createElement(f,r({ref:n},c))}));function f(e,n){var i=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var a=i.length,r=new Array(a);r[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[u]="string"==typeof e?e:t,r[1]=l;for(var p=2;p<a;p++)r[p]=i[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,i)}m.displayName="MDXCreateElement"},7849:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var o=i(7462),t=(i(7294),i(3905));const a={},r="Convenzioni",l={unversionedId:"app/developer/frontend/conventions",id:"app/developer/frontend/conventions",title:"Convenzioni",description:"In questo file vengono descritte un paio di indicazioni generali da seguire nelle contribuzioni di",source:"@site/docs/app/developer/frontend/conventions.md",sourceDirName:"app/developer/frontend",slug:"/app/developer/frontend/conventions",permalink:"/docs/app/developer/frontend/conventions",draft:!1,editUrl:"https://github.com/polinetworkorg/polinetworkdocs/tree/master/docs/app/developer/frontend/conventions.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"roles",permalink:"/docs/app/developer/developer-info"},next:{title:"Components",permalink:"/docs/app/developer/frontend/usefulComponents"}},s={},p=[{value:"Naming",id:"naming",level:2},{value:"Esempi",id:"esempi",level:3},{value:"Typing",id:"typing",level:2},{value:"Definizioni di funzioni",id:"definizioni-di-funzioni",level:3},{value:"Definizioni di componenti",id:"definizioni-di-componenti",level:3},{value:"Altre definizioni con Unknown",id:"altre-definizioni-con-unknown",level:3}],c={toc:p};function u(e){let{components:n,...i}=e;return(0,t.kt)("wrapper",(0,o.Z)({},c,i,{components:n,mdxType:"MDXLayout"}),(0,t.kt)("h1",{id:"convenzioni"},"Convenzioni"),(0,t.kt)("p",null,"In questo file vengono descritte un paio di indicazioni generali da seguire nelle contribuzioni di\ncodice e qualche guida rapida al fine di aiutare a capire un po' di quirk qua e l\xe0"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("strong",{parentName:"li"},(0,t.kt)("a",{parentName:"strong",href:"#naming"},"Naming conventions"))),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("strong",{parentName:"li"},(0,t.kt)("a",{parentName:"strong",href:"#typing"},"Problemi comuni con il type system")))),(0,t.kt)("h2",{id:"naming"},"Naming"),(0,t.kt)("p",null,"In generale si usa il ",(0,t.kt)("inlineCode",{parentName:"p"},"camelCase")," per cose tipo"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"variabili locali"),(0,t.kt)("li",{parentName:"ul"},"funzioni"),(0,t.kt)("li",{parentName:"ul"},"prop dei componenti"),(0,t.kt)("li",{parentName:"ul"},"metodi, attributi e propriet\xe0"),(0,t.kt)("li",{parentName:"ul"},"membri di oggetti e parametri delle funzioni")),(0,t.kt)("p",null,"e il ",(0,t.kt)("inlineCode",{parentName:"p"},"PascalCase")," per le"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"classi"),(0,t.kt)("li",{parentName:"ul"},"componenti (anche se di fatto sono solo funzioni)"),(0,t.kt)("li",{parentName:"ul"},"nomi di tipi e interfacce di typescript")),(0,t.kt)("p",null,"ed se caso si pu\xf2 usare anche il ",(0,t.kt)("inlineCode",{parentName:"p"},"SCREAMING_SNAKE_CASE")," per eventuali costanti."),(0,t.kt)("h3",{id:"esempi"},"Esempi"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-ts"},"// una funzione pura \xe8 in camelCase, cos\xec come i suoi parametri\nfunction helloWorld(name: string) {\n    // variabili in generale sono sempre in camelCase\n    const message = `Hello ${name}`\n    console.log(message)\n}\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-tsx"},"// i componenti sono in PascalCase, ma i props sono in camelCase\nfunction Button(props: { label: string; onClick?: () => void }) {\n    // le variabili locali sono variabili locali normali, quindi in camelCase\n    const [count, setCount] = useState(0)\n\n    return (\n        <Pressable onPress={() => props.onClick()}>\n            <Text>{props.label}</Text>\n        </Pressable>\n    )\n}\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-ts"},'// i nomi delle interfacce anche sono in PascalCase (stesso vale per i tipi), e i membri sono in camelCase\ntype PageName = "home" | "settings"\n\ninterface Bar {\n    foo: PageName\n    bar: number\n}\n\nclass FooBar extends Foo implements Bar {\n    // ...\n\n    // i nomi dei metodi sono comunque in pascalCase\n    print() {\n        console.log(this.foo)\n        console.log(this.bar)\n    }\n}\n')),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-ts"},'// in caso di interfaccia con stesso nome di una classe, la convenzione \xe8 di mettere la lettera "I"\n// davanti al nome dell\'interfaccia\ninterface IFoo {\n    // ...\n}\n\nclass Foo implements IFoo {\n    // ...\n}\n')),(0,t.kt)("h2",{id:"typing"},"Typing"),(0,t.kt)("p",null,"Consiglio di fare riferimento al ",(0,t.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/intro.html"},"TypeSript Handbook")),(0,t.kt)("p",null,"Se non siete familiare con typescript potreste trovarvi in difficolt\xe0 con il definire un paio di\ntipi e essere tentati ad usare ",(0,t.kt)("inlineCode",{parentName:"p"},"any"),"."),(0,t.kt)("p",null,"Questa cosa va assolutamente evitata ad ogni costo perch\xe9 \xe8 l'unico modo per far spuntare fuori bug\nantipatici dove non si riesce a capire perch\xe9 le cose non funzionano."),(0,t.kt)("p",null,"per tanto qua sotto porr\xf2 un paio di semplici esempi di cose non completamente intuitive per evitare\ndi ritrovarvi senza definizione di tipi"),(0,t.kt)("h3",{id:"definizioni-di-funzioni"},"Definizioni di funzioni"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-ts"},'// il tipo di una funzione generica pu\xf2 essere scritto nel modo pi\xf9 semplice con la sitassi dell\'arrow function\nlet function: () => void // questa \xe8 una funzione senza parametri e senza valore restituito\n\n// i parametri possono essere descritti scrivendone il nome e il tipo come normali variabili\nlet func: (a: number, b: string) => void\n\n// il nome assegnato ad un parametro \xe8 completamente arbitrario e usato solo per documentare la funzione\n// in realt\xe0 quando si assegna una funzione si pu\xf2 rinominare il parametro arbitrariamente\nfunc = (x, y) => {\n    // questa definizione \xe8 valida per la dichiarazione di tipi precedente\n    // qui x sar\xe0 un numero e y una stringa\n}\n\n// allo stesso modo il return type non \xe8 strettamente vincolante quando \xe8 void, poich\xe9 javascript\n// ignorer\xe0 qualsiasi valore restituito se non usato\nfunc = (x, y) => {\n    // questa definizione \xe8 comunque valida\n    return "foo"\n}\n')),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-tsx"},'// per quanto riguarda i tipi dei props, la dichiarazione del tipo di una funzione in questo modo \xe8 utile\n// qua non ci interessa definire tipi di parametri o del valore restituito\nlet Button: FC<{\n    label: string\n    onClick?: () => void\n}>\n\n//...\n\nlet Component: FC = () => (\n    <Button\n        label="ciao"\n        onClick={click => {\n            // click qui sar\xe0 di tipo any e typescipt dar\xe0 errore \u274c\n            return "ciao" // dato che il tipo restituito da onClick \xe8 void, return verr\xe0 ignorato in qualsiasi caso\n        }}\n    />\n)\n')),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-tsx"},'// se si vuole fare in modo che venga passato qualcosa alla funzione, si pu\xf2 definire il tipo del parametro\nlet Button: FC<{\n    label: string\n    onClick?: (e: React.MouseEvent) => void\n}>\n\n//...\n\nlet Component: FC = () => (\n    <Button\n        label="ciao"\n        onClick={click => {\n            // Qui click sar\xe0 definito e di tipo React.MouseEvent, anche se nella dichiarazione\n            // di Button sopra \xe8 stato chiamato "e"\n        }}\n    />\n)\n')),(0,t.kt)("h3",{id:"definizioni-di-componenti"},"Definizioni di componenti"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-tsx"},"// se si vuole passare qualche componente come prop, ci sono un paio di tipi che ci vengono in aiuto\n\n// un FunctionComponent (FC) ha come tipo di restituzione React.ReactElement, che \xe8 un tipo generico\n// per i componenti a cui possono essere passati props (di cui a loro volta si pu\xf2 definire il tipo)\nlet Button: FC<{\n    label: string\n    icon: React.ReactElement<IconProps, any>\n}>\n\n// per componenti generici i cui props non sono importanti, si pu\xf2 usare JSX.Element, che \xe8 ugaule a\n// React.ReactElement<any, any>\n\nlet Button: FC<{\n    label: string\n    icon: JSX.Element // pi\xf9 compatto ed inclusivo\n}>\n\n// ReactNode accetta tutto quello che \xe8 considerato un valido nodo di React, quindi componenti ma anche\n// array di componenti, o stringhe (che in react native sono validi nodi solo per <Text>)\n// pu\xf2 essere utilizzato in caso serva pi\xf9 flessibilit\xe0, ma in generale \xe8 meglio JSX.Element\nlet Button: FC<{\n    label: string\n    node: React.ReactNode // questo accetta un po' qualsiasi cosa come nodo\n}>\n")),(0,t.kt)("h3",{id:"altre-definizioni-con-unknown"},"Altre definizioni con Unknown"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-ts"},"// in caso si voglia definire qualche sorta di funzione che potrebbe potenzialmente accettare\n// qualsiasi tipo di parametro, \xe8 preferibile usare unknown al posto di any\n\nfunction log(x: any) {\n    // \u274c qui x sar\xe0 any, quindi qualsiasi parametro \xe8 accessibile anche se non esiste\n    console.log(x)\n    console.log(x.foo) // \u26a0\ufe0f possibile errore di runtime\n}\n\nfunction log(x: unknown) {\n    // \u2705 qui x sar\xe0 unknown, per accedere a parametri \xe8 necessario usare un type guard\n    console.log(x)\n    console.log(x.foo) // \u26a0\ufe0f errore di compilazione, meglio\n}\n")))}u.isMDXComponent=!0}}]);